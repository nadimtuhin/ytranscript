/**
 * Tests for output writers (writeJsonl, appendJsonl, writeCsv)
 */

import { describe, test, expect, beforeEach, afterEach } from 'bun:test';
import { writeJsonl, appendJsonl, writeCsv } from '../src/outputs';
import { readTextFile, fileExists } from '../src/lib/fs';
import { mkdtemp, rm } from 'node:fs/promises';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import type { TranscriptResult } from '../src/types';

describe('writeJsonl', () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await mkdtemp(join(tmpdir(), 'ytranscript-test-'));
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  const mockResult: TranscriptResult = {
    meta: {
      videoId: 'test123',
      title: 'Test Video',
      source: 'manual',
    },
    transcript: {
      videoId: 'test123',
      text: 'Hello world',
      language: 'en',
      isAutoGenerated: false,
      segments: [{ text: 'Hello world', start: 0, duration: 2 }],
    },
  };

  test('writes single result to JSONL', async () => {
    const path = join(tempDir, 'output.jsonl');
    await writeJsonl([mockResult], { path });

    const content = await readTextFile(path);
    const lines = content.trim().split('\n');

    expect(lines).toHaveLength(1);
    expect(JSON.parse(lines[0])).toEqual(mockResult);
  });

  test('writes multiple results to JSONL', async () => {
    const path = join(tempDir, 'output.jsonl');
    const results = [
      mockResult,
      { ...mockResult, meta: { ...mockResult.meta, videoId: 'test456' } },
    ];

    await writeJsonl(results, { path });

    const content = await readTextFile(path);
    const lines = content.trim().split('\n');

    expect(lines).toHaveLength(2);
    expect(JSON.parse(lines[0]).meta.videoId).toBe('test123');
    expect(JSON.parse(lines[1]).meta.videoId).toBe('test456');
  });

  test('overwrites existing file by default', async () => {
    const path = join(tempDir, 'output.jsonl');

    await writeJsonl([mockResult], { path });
    await writeJsonl([{ ...mockResult, meta: { ...mockResult.meta, videoId: 'new' } }], { path });

    const content = await readTextFile(path);
    const lines = content.trim().split('\n');

    expect(lines).toHaveLength(1);
    expect(JSON.parse(lines[0]).meta.videoId).toBe('new');
  });

  test('appends when append option is true', async () => {
    const path = join(tempDir, 'output.jsonl');

    await writeJsonl([mockResult], { path });
    await writeJsonl([{ ...mockResult, meta: { ...mockResult.meta, videoId: 'appended' } }], {
      path,
      append: true,
    });

    const content = await readTextFile(path);
    const lines = content.trim().split('\n');

    expect(lines).toHaveLength(2);
    expect(JSON.parse(lines[0]).meta.videoId).toBe('test123');
    expect(JSON.parse(lines[1]).meta.videoId).toBe('appended');
  });
});

describe('appendJsonl', () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await mkdtemp(join(tmpdir(), 'ytranscript-test-'));
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  const mockResult: TranscriptResult = {
    meta: { videoId: 'test123', source: 'manual' },
    transcript: {
      videoId: 'test123',
      text: 'Hello',
      language: 'en',
      isAutoGenerated: false,
      segments: [],
    },
  };

  test('creates file if it does not exist', async () => {
    const path = join(tempDir, 'new.jsonl');

    expect(await fileExists(path)).toBe(false);
    await appendJsonl(mockResult, path);
    expect(await fileExists(path)).toBe(true);

    const content = await readTextFile(path);
    expect(JSON.parse(content.trim())).toEqual(mockResult);
  });

  test('appends to existing file', async () => {
    const path = join(tempDir, 'existing.jsonl');

    await appendJsonl(mockResult, path);
    await appendJsonl({ ...mockResult, meta: { ...mockResult.meta, videoId: 'second' } }, path);

    const content = await readTextFile(path);
    const lines = content.trim().split('\n');

    expect(lines).toHaveLength(2);
    expect(JSON.parse(lines[0]).meta.videoId).toBe('test123');
    expect(JSON.parse(lines[1]).meta.videoId).toBe('second');
  });

  test('handles concurrent appends without data loss', async () => {
    const path = join(tempDir, 'concurrent.jsonl');
    const count = 20;

    // Create 20 concurrent append operations
    const promises = Array.from({ length: count }, (_, i) =>
      appendJsonl({ ...mockResult, meta: { ...mockResult.meta, videoId: `video${i}` } }, path)
    );

    await Promise.all(promises);

    const content = await readTextFile(path);
    const lines = content.trim().split('\n');

    // All 20 entries should be present (no data loss from race conditions)
    expect(lines).toHaveLength(count);

    // Verify all video IDs are present (order may vary)
    const videoIds = lines.map((line) => JSON.parse(line).meta.videoId);
    for (let i = 0; i < count; i++) {
      expect(videoIds).toContain(`video${i}`);
    }
  });
});

describe('writeCsv', () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await mkdtemp(join(tmpdir(), 'ytranscript-test-'));
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  const mockResult: TranscriptResult = {
    meta: {
      videoId: 'test123',
      title: 'Test Video',
      url: 'https://youtube.com/watch?v=test123',
      channel: { name: 'Test Channel' },
      watchedAt: '2024-01-01T00:00:00Z',
      source: 'history',
    },
    transcript: {
      videoId: 'test123',
      text: 'Hello world',
      language: 'en',
      isAutoGenerated: true,
      segments: [],
    },
  };

  test('writes CSV with headers', async () => {
    const path = join(tempDir, 'output.csv');
    await writeCsv([mockResult], { path });

    const content = await readTextFile(path);
    const lines = content.trim().split('\n');

    expect(lines[0]).toBe(
      'video_id,source,title,url,channel_name,watched_at,language,is_auto_generated,transcript,error'
    );
    expect(lines).toHaveLength(2);
  });

  test('escapes quotes in CSV values', async () => {
    const path = join(tempDir, 'output.csv');
    const resultWithQuotes: TranscriptResult = {
      ...mockResult,
      meta: { ...mockResult.meta, title: 'Video with "quotes"' },
    };

    await writeCsv([resultWithQuotes], { path });

    const content = await readTextFile(path);
    expect(content).toContain('""quotes""');
  });

  test('includes error field when transcript fails', async () => {
    const path = join(tempDir, 'output.csv');
    const failedResult: TranscriptResult = {
      meta: { videoId: 'failed123', source: 'manual' },
      transcript: null,
      error: 'No captions available',
    };

    await writeCsv([failedResult], { path });

    const content = await readTextFile(path);
    expect(content).toContain('No captions available');
  });

  test('appends without headers when file exists', async () => {
    const path = join(tempDir, 'output.csv');

    await writeCsv([mockResult], { path });
    await writeCsv([{ ...mockResult, meta: { ...mockResult.meta, videoId: 'second' } }], {
      path,
      append: true,
    });

    const content = await readTextFile(path);
    const lines = content.trim().split('\n');

    // Should have 1 header + 2 data rows
    expect(lines).toHaveLength(3);
    // Header should appear only once
    expect(content.match(/video_id,source/g)?.length).toBe(1);
  });
});

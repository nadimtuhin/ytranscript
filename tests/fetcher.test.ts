/**
 * Tests for YouTube transcript fetcher with mocked HTTP responses
 */

import { describe, test, expect, beforeEach, afterEach } from 'bun:test';
import { fetchTranscript, extractVideoId } from '../src/lib/fetcher';

// Store original fetch
const originalFetch = globalThis.fetch;

// Helper to create a mock fetch that satisfies Bun's type
function createMockFetch(handler: (url: string) => Promise<Response>) {
  const mockFn = async (input: string | URL | Request, init?: RequestInit) => {
    const url =
      typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;
    return handler(url);
  };
  // Add required Bun properties
  (mockFn as typeof fetch).preconnect = () => {};
  return mockFn as typeof fetch;
}

describe('fetchTranscript', () => {
  afterEach(() => {
    // Restore original fetch after each test
    globalThis.fetch = originalFetch;
  });

  test('successfully fetches transcript', async () => {
    const mockPlayerResponse = {
      captions: {
        playerCaptionsTracklistRenderer: {
          captionTracks: [
            {
              baseUrl: 'https://www.youtube.com/api/timedtext?v=test123&lang=en',
              languageCode: 'en',
              kind: 'asr',
              name: { simpleText: 'English (auto-generated)' },
            },
          ],
        },
      },
    };

    const mockCaptionResponse = {
      events: [
        { segs: [{ utf8: 'Hello ' }, { utf8: 'world' }], tStartMs: 0, dDurationMs: 2000 },
        { segs: [{ utf8: 'This is a test' }], tStartMs: 2000, dDurationMs: 3000 },
      ],
    };

    globalThis.fetch = createMockFetch(async (url) => {
      if (url.includes('youtubei/v1/player')) {
        return new Response(JSON.stringify(mockPlayerResponse), { status: 200 });
      }
      if (url.includes('timedtext')) {
        return new Response(JSON.stringify(mockCaptionResponse), { status: 200 });
      }
      return new Response('Not found', { status: 404 });
    });

    const transcript = await fetchTranscript('test123');

    expect(transcript.videoId).toBe('test123');
    expect(transcript.language).toBe('en');
    expect(transcript.isAutoGenerated).toBe(true);
    expect(transcript.text).toBe('Hello world This is a test');
    expect(transcript.segments).toHaveLength(2);
    expect(transcript.segments[0].text).toBe('Hello world');
    expect(transcript.segments[0].start).toBe(0);
    expect(transcript.segments[0].duration).toBe(2);
  });

  test('throws error when no captions available', async () => {
    const mockPlayerResponse = {
      captions: {
        playerCaptionsTracklistRenderer: {
          captionTracks: [],
        },
      },
    };

    globalThis.fetch = createMockFetch(async () => {
      return new Response(JSON.stringify(mockPlayerResponse), { status: 200 });
    });

    await expect(fetchTranscript('test123')).rejects.toThrow('No captions available');
  });

  test('throws error when player response has no captions field', async () => {
    globalThis.fetch = createMockFetch(async () => {
      return new Response(JSON.stringify({}), { status: 200 });
    });

    await expect(fetchTranscript('test123')).rejects.toThrow('No captions available');
  });

  test('throws error on HTTP error', async () => {
    globalThis.fetch = createMockFetch(async () => {
      return new Response('Server error', { status: 500, statusText: 'Internal Server Error' });
    });

    await expect(fetchTranscript('test123')).rejects.toThrow('HTTP 500');
  });

  test('respects language preference', async () => {
    const mockPlayerResponse = {
      captions: {
        playerCaptionsTracklistRenderer: {
          captionTracks: [
            { baseUrl: 'https://example.com/en', languageCode: 'en' },
            { baseUrl: 'https://example.com/es', languageCode: 'es' },
            { baseUrl: 'https://example.com/fr', languageCode: 'fr' },
          ],
        },
      },
    };

    const mockCaptionResponse = {
      events: [{ segs: [{ utf8: 'Hola mundo' }], tStartMs: 0, dDurationMs: 1000 }],
    };

    let captionUrlCalled = '';

    globalThis.fetch = createMockFetch(async (url) => {
      if (url.includes('youtubei/v1/player')) {
        return new Response(JSON.stringify(mockPlayerResponse), { status: 200 });
      }
      captionUrlCalled = url;
      return new Response(JSON.stringify(mockCaptionResponse), { status: 200 });
    });

    const transcript = await fetchTranscript('test123', { languages: ['es', 'en'] });

    expect(transcript.language).toBe('es');
    expect(captionUrlCalled).toContain('example.com/es');
  });

  test('prefers manual captions over auto-generated', async () => {
    const mockPlayerResponse = {
      captions: {
        playerCaptionsTracklistRenderer: {
          captionTracks: [
            { baseUrl: 'https://example.com/auto', languageCode: 'en', kind: 'asr' },
            { baseUrl: 'https://example.com/manual', languageCode: 'en' },
          ],
        },
      },
    };

    const mockCaptionResponse = {
      events: [{ segs: [{ utf8: 'Manual caption' }], tStartMs: 0, dDurationMs: 1000 }],
    };

    let captionUrlCalled = '';

    globalThis.fetch = createMockFetch(async (url) => {
      if (url.includes('youtubei/v1/player')) {
        return new Response(JSON.stringify(mockPlayerResponse), { status: 200 });
      }
      captionUrlCalled = url;
      return new Response(JSON.stringify(mockCaptionResponse), { status: 200 });
    });

    const transcript = await fetchTranscript('test123', { languages: ['en'] });

    expect(transcript.isAutoGenerated).toBe(false);
    expect(captionUrlCalled).toContain('example.com/manual');
  });

  test('excludes auto-generated when option is false', async () => {
    const mockPlayerResponse = {
      captions: {
        playerCaptionsTracklistRenderer: {
          captionTracks: [{ baseUrl: 'https://example.com/auto', languageCode: 'en', kind: 'asr' }],
        },
      },
    };

    globalThis.fetch = createMockFetch(async () => {
      return new Response(JSON.stringify(mockPlayerResponse), { status: 200 });
    });

    await expect(
      fetchTranscript('test123', { languages: ['en'], includeAutoGenerated: false })
    ).rejects.toThrow('No suitable caption track found');
  });

  test('throws error when caption track is empty', async () => {
    const mockPlayerResponse = {
      captions: {
        playerCaptionsTracklistRenderer: {
          captionTracks: [{ baseUrl: 'https://example.com/en', languageCode: 'en' }],
        },
      },
    };

    globalThis.fetch = createMockFetch(async (url) => {
      if (url.includes('youtubei/v1/player')) {
        return new Response(JSON.stringify(mockPlayerResponse), { status: 200 });
      }
      return new Response(JSON.stringify({ events: [] }), { status: 200 });
    });

    await expect(fetchTranscript('test123')).rejects.toThrow('Caption track is empty');
  });

  test('handles events without segs field', async () => {
    const mockPlayerResponse = {
      captions: {
        playerCaptionsTracklistRenderer: {
          captionTracks: [{ baseUrl: 'https://example.com/en', languageCode: 'en' }],
        },
      },
    };

    const mockCaptionResponse = {
      events: [
        { tStartMs: 0, dDurationMs: 1000 }, // No segs
        { segs: [{ utf8: 'Valid text' }], tStartMs: 1000, dDurationMs: 2000 },
        { segs: [], tStartMs: 3000, dDurationMs: 1000 }, // Empty segs
      ],
    };

    globalThis.fetch = createMockFetch(async (url) => {
      if (url.includes('youtubei/v1/player')) {
        return new Response(JSON.stringify(mockPlayerResponse), { status: 200 });
      }
      return new Response(JSON.stringify(mockCaptionResponse), { status: 200 });
    });

    const transcript = await fetchTranscript('test123');

    expect(transcript.segments).toHaveLength(1);
    expect(transcript.segments[0].text).toBe('Valid text');
  });
});

describe('extractVideoId edge cases', () => {
  test('handles music URL', () => {
    expect(extractVideoId('https://music.youtube.com/watch?v=dQw4w9WgXcQ')).toBe('dQw4w9WgXcQ');
  });

  test('handles URL with extra path segments', () => {
    expect(extractVideoId('https://youtu.be/dQw4w9WgXcQ/')).toBe('dQw4w9WgXcQ');
  });

  test('rejects video ID with wrong length', () => {
    expect(extractVideoId('abc')).toBeNull();
    expect(extractVideoId('abcdefghijkl')).toBeNull(); // 12 chars
  });

  test('rejects video ID with invalid characters', () => {
    expect(extractVideoId('abc!@#$%^&*()')).toBeNull();
  });
});

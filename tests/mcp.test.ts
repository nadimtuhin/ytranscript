/**
 * Tests for MCP server
 */

import { describe, test, expect, spyOn, afterEach } from 'bun:test';
import * as fetcher from '../src/lib/fetcher';
import type { Transcript } from '../src/types';

// Mock transcript response
const mockTranscript: Transcript = {
  videoId: 'dQw4w9WgXcQ',
  text: 'Never gonna give you up, never gonna let you down',
  segments: [
    { text: 'Never gonna give you up', start: 0, duration: 2.5 },
    { text: 'never gonna let you down', start: 2.5, duration: 2.5 },
  ],
  language: 'en',
  isAutoGenerated: false,
};

describe('MCP server tools', () => {
  afterEach(() => {
    // Restore all mocks after each test
  });

  test('extract_video_id extracts from URL', () => {
    const { extractVideoId } = fetcher;
    
    expect(extractVideoId('https://www.youtube.com/watch?v=dQw4w9WgXcQ')).toBe('dQw4w9WgXcQ');
    expect(extractVideoId('https://youtu.be/dQw4w9WgXcQ')).toBe('dQw4w9WgXcQ');
    expect(extractVideoId('dQw4w9WgXcQ')).toBe('dQw4w9WgXcQ');
  });

  test('extract_video_id returns null for invalid input', () => {
    const { extractVideoId } = fetcher;
    
    expect(extractVideoId('invalid')).toBeNull();
    expect(extractVideoId('https://example.com')).toBeNull();
  });

  test('fetchTranscript returns transcript data', async () => {
    const fetchSpy = spyOn(fetcher, 'fetchTranscript').mockResolvedValue(mockTranscript);

    const result = await fetcher.fetchTranscript('dQw4w9WgXcQ', { languages: ['en'] });

    expect(result.videoId).toBe('dQw4w9WgXcQ');
    expect(result.text).toContain('Never gonna give you up');
    expect(result.segments).toHaveLength(2);
    expect(result.language).toBe('en');

    fetchSpy.mockRestore();
  });

  test('fetchTranscript handles errors', async () => {
    const fetchSpy = spyOn(fetcher, 'fetchTranscript').mockRejectedValue(
      new Error('No captions available for this video')
    );

    await expect(fetcher.fetchTranscript('invalid123')).rejects.toThrow('No captions available');

    fetchSpy.mockRestore();
  });
});

describe('MCP tool response format', () => {
  test('formatSrt produces valid SRT format', async () => {
    const { formatSrt } = await import('../src/outputs');
    const srt = formatSrt(mockTranscript);

    expect(srt).toContain('1\n');
    expect(srt).toContain('00:00:00,000 --> 00:00:02,500');
    expect(srt).toContain('Never gonna give you up');
  });

  test('formatVtt produces valid VTT format', async () => {
    const { formatVtt } = await import('../src/outputs');
    const vtt = formatVtt(mockTranscript);

    expect(vtt).toStartWith('WEBVTT');
    expect(vtt).toContain('00:00:00.000 --> 00:00:02.500');
  });

  test('formatText returns plain text', async () => {
    const { formatText } = await import('../src/outputs');
    const text = formatText(mockTranscript);

    expect(text).toBe('Never gonna give you up, never gonna let you down');
  });

  test('formatText with timestamps', async () => {
    const { formatText } = await import('../src/outputs');
    const text = formatText(mockTranscript, true);

    expect(text).toContain('[0:00] Never gonna give you up');
    expect(text).toContain('[0:02] never gonna let you down');
  });
});

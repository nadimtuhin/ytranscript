/**
 * Tests for processor (bulk processing)
 */

import { describe, test, expect, mock, spyOn } from 'bun:test';
import { processVideos, streamVideos } from '../src/lib/processor';
import * as fetcher from '../src/lib/fetcher';
import type { WatchHistoryMeta, Transcript } from '../src/types';

// Mock transcript response
const mockTranscript: Transcript = {
  videoId: 'test123',
  text: 'Hello world',
  segments: [{ text: 'Hello world', start: 0, duration: 2 }],
  language: 'en',
  isAutoGenerated: false,
};

describe('processVideos', () => {
  test('processes videos and returns results', async () => {
    const fetchSpy = spyOn(fetcher, 'fetchTranscript').mockResolvedValue(mockTranscript);

    const videos: WatchHistoryMeta[] = [
      { videoId: 'vid1', source: 'manual' },
      { videoId: 'vid2', source: 'manual' },
    ];

    const results = await processVideos(videos, { concurrency: 2 });

    expect(results).toHaveLength(2);
    expect(results[0].transcript).not.toBeNull();
    expect(fetchSpy).toHaveBeenCalledTimes(2);

    fetchSpy.mockRestore();
  });

  test('handles fetch errors gracefully', async () => {
    const fetchSpy = spyOn(fetcher, 'fetchTranscript').mockRejectedValue(
      new Error('No captions available')
    );

    const videos: WatchHistoryMeta[] = [{ videoId: 'vid1', source: 'manual' }];

    const results = await processVideos(videos);

    expect(results).toHaveLength(1);
    expect(results[0].transcript).toBeNull();
    expect(results[0].error).toBe('No captions available');

    fetchSpy.mockRestore();
  });

  test('skips already processed videos', async () => {
    const fetchSpy = spyOn(fetcher, 'fetchTranscript').mockResolvedValue(mockTranscript);

    const videos: WatchHistoryMeta[] = [
      { videoId: 'vid1', source: 'manual' },
      { videoId: 'vid2', source: 'manual' },
      { videoId: 'vid3', source: 'manual' },
    ];

    const skipIds = new Set(['vid1', 'vid3']);
    const results = await processVideos(videos, { skipIds });

    expect(results).toHaveLength(1);
    expect(results[0].meta.videoId).toBe('vid2');
    expect(fetchSpy).toHaveBeenCalledTimes(1);

    fetchSpy.mockRestore();
  });

  test('calls onProgress callback', async () => {
    const fetchSpy = spyOn(fetcher, 'fetchTranscript').mockResolvedValue(mockTranscript);

    const videos: WatchHistoryMeta[] = [
      { videoId: 'vid1', source: 'manual' },
      { videoId: 'vid2', source: 'manual' },
    ];

    const progressCalls: Array<{ completed: number; total: number }> = [];

    await processVideos(videos, {
      concurrency: 1,
      onProgress: (completed, total) => {
        progressCalls.push({ completed, total });
      },
    });

    expect(progressCalls).toHaveLength(2);
    expect(progressCalls[0]).toEqual({ completed: 1, total: 2 });
    expect(progressCalls[1]).toEqual({ completed: 2, total: 2 });

    fetchSpy.mockRestore();
  });

  test('returns empty array when all videos are skipped', async () => {
    const videos: WatchHistoryMeta[] = [
      { videoId: 'vid1', source: 'manual' },
      { videoId: 'vid2', source: 'manual' },
    ];

    const skipIds = new Set(['vid1', 'vid2']);
    const results = await processVideos(videos, { skipIds });

    expect(results).toHaveLength(0);
  });

  test('respects concurrency limit', async () => {
    let concurrent = 0;
    let maxConcurrent = 0;

    const fetchSpy = spyOn(fetcher, 'fetchTranscript').mockImplementation(async () => {
      concurrent++;
      maxConcurrent = Math.max(maxConcurrent, concurrent);
      await new Promise((r) => setTimeout(r, 50));
      concurrent--;
      return mockTranscript;
    });

    const videos: WatchHistoryMeta[] = Array.from({ length: 10 }, (_, i) => ({
      videoId: `vid${i}`,
      source: 'manual' as const,
    }));

    await processVideos(videos, { concurrency: 3, pauseAfter: 100, pauseDuration: 0 });

    expect(maxConcurrent).toBeLessThanOrEqual(3);

    fetchSpy.mockRestore();
  });
});

describe('streamVideos', () => {
  test('yields results as they complete', async () => {
    const fetchSpy = spyOn(fetcher, 'fetchTranscript').mockResolvedValue(mockTranscript);

    const videos: WatchHistoryMeta[] = [
      { videoId: 'vid1', source: 'manual' },
      { videoId: 'vid2', source: 'manual' },
    ];

    const results: string[] = [];
    for await (const result of streamVideos(videos, { concurrency: 1 })) {
      results.push(result.meta.videoId);
    }

    expect(results).toHaveLength(2);
    expect(results).toContain('vid1');
    expect(results).toContain('vid2');

    fetchSpy.mockRestore();
  });

  test('handles errors in stream', async () => {
    const fetchSpy = spyOn(fetcher, 'fetchTranscript')
      .mockResolvedValueOnce(mockTranscript)
      .mockRejectedValueOnce(new Error('Failed'));

    const videos: WatchHistoryMeta[] = [
      { videoId: 'vid1', source: 'manual' },
      { videoId: 'vid2', source: 'manual' },
    ];

    const results = [];
    for await (const result of streamVideos(videos, { concurrency: 1 })) {
      results.push(result);
    }

    expect(results).toHaveLength(2);
    expect(results[0].transcript).not.toBeNull();
    expect(results[1].transcript).toBeNull();
    expect(results[1].error).toBe('Failed');

    fetchSpy.mockRestore();
  });

  test('skips already processed videos', async () => {
    const fetchSpy = spyOn(fetcher, 'fetchTranscript').mockResolvedValue(mockTranscript);

    const videos: WatchHistoryMeta[] = [
      { videoId: 'vid1', source: 'manual' },
      { videoId: 'vid2', source: 'manual' },
    ];

    const results = [];
    for await (const result of streamVideos(videos, { skipIds: new Set(['vid1']) })) {
      results.push(result);
    }

    expect(results).toHaveLength(1);
    expect(results[0].meta.videoId).toBe('vid2');

    fetchSpy.mockRestore();
  });

  test('yields nothing when all videos skipped', async () => {
    const videos: WatchHistoryMeta[] = [{ videoId: 'vid1', source: 'manual' }];

    const results = [];
    for await (const result of streamVideos(videos, { skipIds: new Set(['vid1']) })) {
      results.push(result);
    }

    expect(results).toHaveLength(0);
  });
});

#!/usr/bin/env node
/**
 * ytranscript MCP Server
 *
 * Exposes YouTube transcript extraction as MCP tools for AI assistants
 */

import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { z } from 'zod';

import { extractVideoId, fetchTranscript } from './lib/fetcher';
import { formatSrt, formatText, formatVtt } from './outputs';

// Create MCP server
const server = new McpServer({
  name: 'ytranscript',
  version: '0.1.0',
});

// Tool: Get transcript for a YouTube video
server.tool(
  'get_transcript',
  'Fetch the transcript/captions for a YouTube video. Returns the full text and optionally segments with timestamps.',
  {
    video: z
      .string()
      .describe(
        'YouTube video ID or URL (e.g., "dQw4w9WgXcQ" or "https://youtube.com/watch?v=dQw4w9WgXcQ")'
      ),
    language: z
      .string()
      .optional()
      .describe('Preferred language code (e.g., "en", "es", "fr"). Defaults to "en"'),
    format: z
      .enum(['text', 'segments', 'srt', 'vtt'])
      .optional()
      .describe(
        'Output format: "text" (plain text), "segments" (with timestamps), "srt" (subtitle format), "vtt" (web subtitle format). Defaults to "text"'
      ),
    include_timestamps: z
      .boolean()
      .optional()
      .describe(
        'Include timestamps in text output. Only applies when format is "text". Defaults to false'
      ),
  },
  async ({ video, language = 'en', format = 'text', include_timestamps = false }) => {
    const videoId = extractVideoId(video);

    if (!videoId) {
      return {
        content: [
          {
            type: 'text' as const,
            text: `Error: Invalid YouTube video ID or URL: "${video}"`,
          },
        ],
        isError: true,
      };
    }

    try {
      const transcript = await fetchTranscript(videoId, {
        languages: [language],
        includeAutoGenerated: true,
      });

      let output: string;

      switch (format) {
        case 'segments':
          output = JSON.stringify(
            {
              videoId: transcript.videoId,
              language: transcript.language,
              isAutoGenerated: transcript.isAutoGenerated,
              segments: transcript.segments,
            },
            null,
            2
          );
          break;
        case 'srt':
          output = formatSrt(transcript);
          break;
        case 'vtt':
          output = formatVtt(transcript);
          break;
        default:
          output = formatText(transcript, include_timestamps);
      }

      return {
        content: [
          {
            type: 'text' as const,
            text: output,
          },
        ],
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      return {
        content: [
          {
            type: 'text' as const,
            text: `Error fetching transcript for ${videoId}: ${message}`,
          },
        ],
        isError: true,
      };
    }
  }
);

// Tool: Get available transcript languages for a video
server.tool(
  'get_transcript_languages',
  'Get a list of available transcript/caption languages for a YouTube video',
  {
    video: z.string().describe('YouTube video ID or URL'),
  },
  async ({ video }) => {
    const videoId = extractVideoId(video);

    if (!videoId) {
      return {
        content: [
          {
            type: 'text' as const,
            text: `Error: Invalid YouTube video ID or URL: "${video}"`,
          },
        ],
        isError: true,
      };
    }

    try {
      const response = await fetch('https://www.youtube.com/youtubei/v1/player?prettyPrint=false', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          context: {
            client: { clientName: 'WEB', clientVersion: '2.20240101.00.00' },
          },
          videoId,
        }),
      });

      const data = (await response.json()) as {
        captions?: {
          playerCaptionsTracklistRenderer?: {
            captionTracks?: Array<{
              languageCode: string;
              kind?: string;
              name?: { simpleText?: string };
            }>;
          };
        };
      };

      const tracks = data.captions?.playerCaptionsTracklistRenderer?.captionTracks || [];

      if (!tracks.length) {
        return {
          content: [
            {
              type: 'text' as const,
              text: `No captions available for video ${videoId}`,
            },
          ],
        };
      }

      const languages = tracks.map((track) => ({
        code: track.languageCode,
        name: track.name?.simpleText || track.languageCode,
        isAutoGenerated: track.kind === 'asr',
      }));

      return {
        content: [
          {
            type: 'text' as const,
            text: JSON.stringify({ videoId, languages }, null, 2),
          },
        ],
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      return {
        content: [
          {
            type: 'text' as const,
            text: `Error fetching languages for ${videoId}: ${message}`,
          },
        ],
        isError: true,
      };
    }
  }
);

// Tool: Extract video ID from URL
server.tool(
  'extract_video_id',
  'Extract the YouTube video ID from various URL formats',
  {
    url: z.string().describe('YouTube URL or video ID'),
  },
  async ({ url }) => {
    const videoId = extractVideoId(url);

    if (!videoId) {
      return {
        content: [
          {
            type: 'text' as const,
            text: `Could not extract video ID from: "${url}"`,
          },
        ],
        isError: true,
      };
    }

    return {
      content: [
        {
          type: 'text' as const,
          text: videoId,
        },
      ],
    };
  }
);

// Tool: Get transcripts for multiple videos
server.tool(
  'get_transcripts_bulk',
  'Fetch transcripts for multiple YouTube videos at once. Returns results for each video.',
  {
    videos: z.array(z.string()).describe('Array of YouTube video IDs or URLs'),
    language: z.string().optional().describe('Preferred language code. Defaults to "en"'),
  },
  async ({ videos, language = 'en' }) => {
    const results: Array<{
      videoId: string;
      success: boolean;
      text?: string;
      error?: string;
    }> = [];

    for (const video of videos) {
      const videoId = extractVideoId(video);

      if (!videoId) {
        results.push({
          videoId: video,
          success: false,
          error: 'Invalid video ID or URL',
        });
        continue;
      }

      try {
        const transcript = await fetchTranscript(videoId, {
          languages: [language],
          includeAutoGenerated: true,
        });

        results.push({
          videoId,
          success: true,
          text: transcript.text,
        });
      } catch (error) {
        results.push({
          videoId,
          success: false,
          error: error instanceof Error ? error.message : String(error),
        });
      }
    }

    const successful = results.filter((r) => r.success).length;
    const failed = results.filter((r) => !r.success).length;

    return {
      content: [
        {
          type: 'text' as const,
          text: JSON.stringify(
            {
              summary: { total: videos.length, successful, failed },
              results,
            },
            null,
            2
          ),
        },
      ],
    };
  }
);

// Start server
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('ytranscript MCP server running on stdio');
}

main().catch((error) => {
  console.error('Failed to start MCP server:', error);
  process.exit(1);
});

/**
 * Output writers for different formats
 */

import type { TranscriptResult, Transcript, OutputOptions } from '../types';

/**
 * Write results to JSONL format (one JSON object per line)
 */
export async function writeJsonl(
  results: TranscriptResult[],
  options: OutputOptions
): Promise<void> {
  const lines = results.map((r) => JSON.stringify(r));
  const content = lines.join('\n') + '\n';

  if (options.append) {
    await Bun.write(options.path, content, { mode: 'a' as unknown as number });
  } else {
    await Bun.write(options.path, content);
  }
}

/**
 * Append a single result to JSONL file (for streaming)
 */
export async function appendJsonl(
  result: TranscriptResult,
  path: string
): Promise<void> {
  const file = Bun.file(path);
  const existing = (await file.exists()) ? await file.text() : '';
  const newContent = existing + JSON.stringify(result) + '\n';
  await Bun.write(path, newContent);
}

/**
 * Write results to CSV format
 */
export async function writeCsv(
  results: TranscriptResult[],
  options: OutputOptions
): Promise<void> {
  const headers = [
    'video_id',
    'source',
    'title',
    'url',
    'channel_name',
    'watched_at',
    'language',
    'is_auto_generated',
    'transcript',
    'error',
  ];

  const rows = results.map((r) => [
    r.meta.videoId,
    r.meta.source,
    r.meta.title || '',
    r.meta.url || '',
    r.meta.channel?.name || '',
    r.meta.watchedAt || '',
    r.transcript?.language || '',
    r.transcript?.isAutoGenerated ? 'true' : 'false',
    r.transcript?.text || '',
    r.error || '',
  ]);

  const csvContent = [
    headers.join(','),
    ...rows.map((row) =>
      row.map((cell) => `"${String(cell).replace(/"/g, '""')}"`).join(',')
    ),
  ].join('\n');

  if (options.append) {
    const file = Bun.file(options.path);
    const existing = (await file.exists()) ? await file.text() : '';
    // Skip header if file already has content
    const content = existing
      ? rows
          .map((row) =>
            row.map((cell) => `"${String(cell).replace(/"/g, '""')}"`).join(',')
          )
          .join('\n') + '\n'
      : csvContent + '\n';
    await Bun.write(options.path, existing + content);
  } else {
    await Bun.write(options.path, csvContent + '\n');
  }
}

/**
 * Format transcript as SRT subtitle format
 */
export function formatSrt(transcript: Transcript): string {
  const lines: string[] = [];

  transcript.segments.forEach((segment, index) => {
    const startTime = formatSrtTime(segment.start);
    const endTime = formatSrtTime(segment.start + segment.duration);

    lines.push(String(index + 1));
    lines.push(`${startTime} --> ${endTime}`);
    lines.push(segment.text);
    lines.push('');
  });

  return lines.join('\n');
}

/**
 * Format transcript as VTT subtitle format
 */
export function formatVtt(transcript: Transcript): string {
  const lines: string[] = ['WEBVTT', ''];

  transcript.segments.forEach((segment) => {
    const startTime = formatVttTime(segment.start);
    const endTime = formatVttTime(segment.start + segment.duration);

    lines.push(`${startTime} --> ${endTime}`);
    lines.push(segment.text);
    lines.push('');
  });

  return lines.join('\n');
}

/**
 * Format transcript as plain text
 */
export function formatText(
  transcript: Transcript,
  includeTimestamps = false
): string {
  if (!includeTimestamps) {
    return transcript.text;
  }

  return transcript.segments
    .map((s) => `[${formatTimestamp(s.start)}] ${s.text}`)
    .join('\n');
}

// Helper functions

function formatSrtTime(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);

  return `${pad(hours, 2)}:${pad(minutes, 2)}:${pad(secs, 2)},${pad(ms, 3)}`;
}

function formatVttTime(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);

  return `${pad(hours, 2)}:${pad(minutes, 2)}:${pad(secs, 2)}.${pad(ms, 3)}`;
}

function formatTimestamp(seconds: number): string {
  const minutes = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${minutes}:${pad(secs, 2)}`;
}

function pad(num: number, size: number): string {
  return String(num).padStart(size, '0');
}

/**
 * YouTube transcript fetcher using YouTube's innertube API
 * No third-party services required
 */

import { createRequire } from 'node:module';
import type { Dispatcher } from 'undici';
import type { FetchOptions, ProxyConfig, Transcript, TranscriptSegment } from '../types';

// Bun's bundled undici doesn't export ProxyAgent, so we load it from the npm package
const require = createRequire(import.meta.url);
const ProxyAgent = require('undici/lib/dispatcher/proxy-agent') as new (url: string) => Dispatcher;

const USER_AGENT =
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36';

export interface CaptionTrack {
  baseUrl: string;
  languageCode: string;
  kind?: string;
  name?: { simpleText?: string };
}

interface PlayerResponse {
  captions?: {
    playerCaptionsTracklistRenderer?: {
      captionTracks?: CaptionTrack[];
    };
  };
}

/**
 * Extract video ID from various YouTube URL formats
 */
export function extractVideoId(input: string): string | null {
  // Already a video ID (11 chars, alphanumeric + _ -)
  if (/^[a-zA-Z0-9_-]{11}$/.test(input)) {
    return input;
  }

  try {
    const url = new URL(input);

    // youtube.com/watch?v=VIDEO_ID
    if (url.hostname.includes('youtube.com')) {
      const v = url.searchParams.get('v');
      if (v && /^[a-zA-Z0-9_-]{11}$/.test(v)) return v;
    }

    // youtu.be/VIDEO_ID
    if (url.hostname === 'youtu.be') {
      const id = url.pathname.slice(1).split('/')[0];
      if (/^[a-zA-Z0-9_-]{11}$/.test(id)) return id;
    }

    // youtube.com/embed/VIDEO_ID
    if (url.pathname.startsWith('/embed/')) {
      const id = url.pathname.split('/')[2];
      if (/^[a-zA-Z0-9_-]{11}$/.test(id)) return id;
    }
  } catch {
    // Not a valid URL
  }

  return null;
}

/**
 * Create a proxy agent if proxy config is provided or found in environment
 */
function createProxyAgent(proxy?: ProxyConfig): Dispatcher | undefined {
  if (proxy) {
    return new ProxyAgent(proxy.url);
  }

  // Fallback to environment variables
  const envProxy =
    process.env.HTTP_PROXY ||
    process.env.http_proxy ||
    process.env.HTTPS_PROXY ||
    process.env.https_proxy;

  if (envProxy) {
    return new ProxyAgent(envProxy);
  }

  return undefined;
}

/**
 * Fetch the player response from YouTube to get caption track URLs
 */
async function fetchPlayerResponse(
  videoId: string,
  timeout: number,
  proxy?: ProxyConfig
): Promise<PlayerResponse> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  const dispatcher = createProxyAgent(proxy);

  try {
    // Use YouTube's innertube API
    const response = await fetch('https://www.youtube.com/youtubei/v1/player?prettyPrint=false', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': USER_AGENT,
      },
      body: JSON.stringify({
        context: {
          client: {
            clientName: 'WEB',
            clientVersion: '2.20240101.00.00',
          },
        },
        videoId,
      }),
      signal: controller.signal,
      ...(dispatcher && { dispatcher }),
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }

    return (await response.json()) as PlayerResponse;
  } finally {
    clearTimeout(timeoutId);
  }
}

/**
 * Fetch and parse a caption track
 */
async function fetchCaptionTrack(
  url: string,
  timeout: number,
  proxy?: ProxyConfig
): Promise<TranscriptSegment[]> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  const dispatcher = createProxyAgent(proxy);

  try {
    // Request JSON format
    const jsonUrl = `${url}&fmt=json3`;
    const response = await fetch(jsonUrl, {
      headers: { 'User-Agent': USER_AGENT },
      signal: controller.signal,
      ...(dispatcher && { dispatcher }),
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const data = (await response.json()) as {
      events?: Array<{ segs?: Array<{ utf8?: string }>; tStartMs?: number; dDurationMs?: number }>;
    };
    const events = data.events || [];

    const segments: TranscriptSegment[] = [];

    for (const event of events) {
      if (!event.segs) continue;

      const text = event.segs
        .map((seg: { utf8?: string }) => seg.utf8 || '')
        .join('')
        .trim();

      if (!text) continue;

      segments.push({
        text,
        start: (event.tStartMs || 0) / 1000,
        duration: (event.dDurationMs || 0) / 1000,
      });
    }

    return segments;
  } finally {
    clearTimeout(timeoutId);
  }
}

/**
 * Select the best caption track based on preferences
 */
function selectCaptionTrack(
  tracks: CaptionTrack[],
  preferredLanguages: string[],
  includeAutoGenerated: boolean
): CaptionTrack | null {
  if (!tracks.length) return null;

  // Separate manual and auto-generated tracks
  const manual = tracks.filter((t) => t.kind !== 'asr');
  const auto = tracks.filter((t) => t.kind === 'asr');

  const searchOrder = includeAutoGenerated ? [...manual, ...auto] : manual;

  // First, try preferred languages in order
  for (const lang of preferredLanguages) {
    const match = searchOrder.find((t) =>
      t.languageCode.toLowerCase().startsWith(lang.toLowerCase())
    );
    if (match) return match;
  }

  // Fallback to first available
  return searchOrder[0] || null;
}

/**
 * Fetch available caption tracks for a video
 */
export async function fetchVideoInfo(
  videoId: string,
  options: FetchOptions = {}
): Promise<CaptionTrack[]> {
  const { timeout = 30000, proxy } = options;
  const playerResponse = await fetchPlayerResponse(videoId, timeout, proxy);
  return playerResponse.captions?.playerCaptionsTracklistRenderer?.captionTracks || [];
}

/**
 * Fetch transcript for a single video
 */
export async function fetchTranscript(
  videoId: string,
  options: FetchOptions = {}
): Promise<Transcript> {
  const { languages = ['en'], timeout = 30000, includeAutoGenerated = true, proxy } = options;

  const playerResponse = await fetchPlayerResponse(videoId, timeout, proxy);

  const captionTracks = playerResponse.captions?.playerCaptionsTracklistRenderer?.captionTracks;

  if (!captionTracks?.length) {
    throw new Error('No captions available for this video');
  }

  const selectedTrack = selectCaptionTrack(captionTracks, languages, includeAutoGenerated);

  if (!selectedTrack) {
    throw new Error('No suitable caption track found');
  }

  const segments = await fetchCaptionTrack(selectedTrack.baseUrl, timeout, proxy);

  if (!segments.length) {
    throw new Error('Caption track is empty');
  }

  const fullText = segments.map((s) => s.text).join(' ');

  return {
    videoId,
    text: fullText,
    segments,
    language: selectedTrack.languageCode,
    isAutoGenerated: selectedTrack.kind === 'asr',
  };
}
